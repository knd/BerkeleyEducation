##
# Node: The abstract base class of all DOM nodes.
#
def Node = Object:new({ \
  __qt=null, __eventListenersBound=0, \
  x=0, y=0, width=0, height=0, color="black", opacity="1", \
  topMargin=0, rightMargin=0, bottomMargin=0, leftMargin=0, \
  topPadding=0, rightPadding=0, bottomPadding=0, leftPadding=0 \
})

##
# Subclasses of Node should override the visitor methods if they have children.
#
Node.visitInPreorder = lambda(self) { yield(self) }
Node.visitInPostorder = lambda(self) { yield(self) }

##
# Declare the methods for the phases of the DOM layout algorithm.
# 1.) Compute this node's width as a function of its parent's (top-down).
# 2.) Layout the children relative to this node and appropriately increase
#     this node's height (bottom-up).
# 3.) Translate relative coordinates into absolute ones (top-down).
# 4.) Render each node to the canvas (top-down).
# 5.) Bind event listeners to each node as appropriate (top-down).
#
Node.pass1_ComputeWidth = lambda(self) { }
Node.pass2_LayoutAndComputeHeight = lambda(self) { }
Node.pass3_ComputeAbsolutePositions = lambda(self) {
  self.x = self.x + self.parent.x
  self.y = self.y + self.parent.y
}
Node.pass4_Render = lambda(self) { }
Node.pass5_BindEventListeners = lambda(self) {
  def register(node) {
    if ("onclick" in self) {
      node:addProxyEventListener("click", self.onclick, self)
    }
  }

  # Attach the event listeners to the descendents and this node.
  for (node in postorder(self)) {
    register(node)
  }
}

##
# Attaches an event listener to this node for the given event. The provided
# callback must be a string of 164 code to be executed in the context of this
# node. Alternatively, it may be a lambda.
#
Node.addEventListener = lambda(self, event, callback) {
  native runtime.addEventListener({node=self, event=event, code=callback})
}

##
# A method similar to addEventListener, except that the value of "self" for
# the callback may be specified independently of the node that recieves the
# event.
#
Node.addProxyEventListener = lambda(self, event, callback, context) {
  def args = {node=self, event=event, code=callback, context=context}
  native runtime.addEventListener(args)
}

##
# Clone method, perform deep copy of nodes
#
Node.clone = lambda (self) {
  # all attributesare copied to the new object
  def clone = {}

  #TODO Fix prototype links!
  clone.visitInPreorder = self.visitInPreorder
  clone.visitInPostorder = self.visitInPostorder
  clone.pass1_ComputeWidth = self.pass1_ComputeWidth
  clone.pass2_LayoutAndComputeHeight = self.pass2_LayoutAndComputeHeight
  clone.pass3_ComputeAbsolutePositions = self.pass3_ComputeAbsolutePositions
  clone.pass4_Render = self.pass4_Render
  clone.pass5_BindEventListeners = self.pass5_BindEventListeners
  clone.addEventListener = self.addEventListener
  clone.addProxyEventListener = self.addProxyEventListener
  
  clone.name   = self.name
  clone.x      = self.x
  clone.y      = self.y
  clone.width  = self.width
  clone.height = self.height
  clone.color  = self.color
  clone.opacity = self.opacity
  
  clone.topMargin     = self.topMargin     
  clone.rightMargin   = self.rightMargin  
  clone.bottomMargin  = self.bottomMargin  
  clone.leftMargin    = self.leftMargin    
  clone.topPadding    = self.topPadding    
  clone.rightPadding  = self.rightPadding  
  clone.bottomPadding = self.bottomPadding 
  clone.leftPadding   = self.leftPadding  
  
  if ("klass" in self) { clone.klass = self.klass }
  if ("parent" in self) { clone.parent = self.parent }
  clone.children = {}
  for (c in self.children) {
    def n = c:clone()
	append(clone.children, n)
	n.parent = clone
  }
  
  clone.__eventListenersBound=0 # We do not rebind event listener
  clone.__qt = null # the clone will receive its qtwidget during rendering
  clone
}

##
# TODO: use coroutine to develop preorder tree iterator rooted at the given node.
def preorder(node) {
	wrap(lambda(_) {node.visitInPreorder(node)}, null)
}

##
# TODO: use coroutine to develop postorder tree iterator rooted at the given node.
def postorder(node) {
	wrap(lambda(_) {node.visitInPostorder(node)}, null)
}
